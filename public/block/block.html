<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Block Blast - Tutyxs 6.0 (√çm√£ Inteligente)</title>
  <style>
    * {
      margin: 0;
      padding: 0;
	      box-sizing: border-box;
	      -webkit-user-select: none; /* Safari */
	      -moz-user-select: none; /* Firefox */
	      -ms-user-select: none; /* IE10+ */
	      user-select: none; /* Standard */
	    }

body {
	      /* O fundo.gif agora √© aplicado ao pseudo-elemento ::before para permitir o filtro de brilho isolado */
      color: white;
      font-family: 'Arial', sans-serif;
      text-align: center;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center; /* Revertido para centralizar verticalmente */
	      padding: 15px;
      overflow: hidden; /* Revertido para ocultar rolagem, como estava originalmente */
	    }
	
	    body::before {
	      content: '';
	      position: fixed;
	      top: 0;
	      left: 0;
	      width: 100%;
	      height: 100%;
	      background: url('fundo.gif') no-repeat center center fixed;
	      background-size: cover;
	      z-index: -1; /* Coloca o fundo atr√°s do conte√∫do */
	      transition: filter 0.5s ease; /* Transi√ß√£o suave para o filtro */
	    }

    #backToSiteBtn {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.3);
      color: white;
      border: 2px solid white;
      padding: 10px;
      border-radius: 50%;
      cursor: pointer;
	      font-size: 1.2rem;
      font-weight: bold;
      z-index: 1000;
      transition: all 0.3s ease-in-out;
      display: flex;
      align-items: center;
      justify-content: center;
	      width: 40px;
	      height: 40px;
      text-decoration: none;
    }

    #backToSiteBtn:hover {
      background: rgba(255, 255, 255, 0.5);
      transform: scale(1.1);
    }

    #backToSiteBtn:active {
      width: auto;
      border-radius: 10px;
	      padding: 5px 10px;
    }

    #backToSiteBtn .arrow {
      margin-right: 0;
      transition: margin-right 0.3s;
    }

    #backToSiteBtn:active .arrow {
	      margin-right: 5px;
    }

    #backToSiteBtn .text {
      display: none;
      white-space: nowrap;
    }

    #backToSiteBtn:active .text {
      display: inline;
    }

.container {
	      max-width: 350px;
	      width: 100%;
	      background: transparent; /* Padr√£o sem fundo */
	      padding: 20px;
	      border-radius: 30px;
	      box-shadow: none;
	    }

	    .header {
	      display: flex;
	      justify-content: space-between;
	      align-items: center;
	      margin-bottom: 10px;
	      gap: 20px;
	    }

    .score-display {
      font-size: 2rem;
      font-weight: bold;
      color: #FFD700;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .score-display::before {
      content: "üëë";
      font-size: 2rem;
    }

    .level-display {
      font-size: 1.5rem;
      font-weight: bold;
      background: rgba(0, 0, 0, 0.3);
      padding: 15px 25px;
      border-radius: 15px;
      border: 3px solid rgba(255, 255, 255, 0.3);
    }

    .settings-btn {
      font-size: 1.5rem;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.3);
      padding: 10px 15px;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      color: white;
    }

    .settings-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(1.1);
    }

.game-board {
	      background: #1a2a5a; /* Removendo o blur */
	      border: 4px solid rgba(255, 255, 255, 0.3);
	      border-radius: 15px;
	      padding: 10px;
	      margin-bottom: 10px;
	      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 0, 0, 0.3);
	      display: grid;
	      grid-template-columns: repeat(6, 1fr);
	      gap: 8px;
	    }

    .cell {
      aspect-ratio: 1;
      background: rgba(0, 0, 0, 0.3);
      border: 3px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      user-select: none;
    }

    .cell:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.4);
    }

    .cell.filled {
      border-color: rgba(255, 255, 255, 0.5);
      box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5), 0 0 10px rgba(0, 0, 0, 0.2);
    }

    /* Estilo para o Ghost Block */
    .cell.preview {
      box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
      opacity: 0.3; /* Opacidade para o efeito Ghost */
      border: 3px solid var(--preview-color) !important; /* Borda da cor do bloco */
    }
    
    /* Estilo para o efeito de linha cheia no preview */
    .cell.clearing-preview {
      opacity: 0.8; /* Mais vis√≠vel que o ghost block */
      box-shadow: 0 0 10px var(--preview-color), 0 0 20px var(--preview-color); /* Brilho ao redor */
      border: 3px solid var(--preview-color) !important;
      background: var(--preview-color) !important; /* Cor do bloco */
    }
    
	    /* Estilo para o efeito de brilho ao limpar a linha */
	    .cell.clearing {
	      animation: cellGlow 0.5s ease-in-out forwards;
	      border: none !important; /* Remove a borda para evitar o artefato de "linha cortando" */
	      box-shadow: none !important; /* Remove a sombra para evitar o artefato de "linha cortando" */
	    }
    
    @keyframes cellGlow {
	      0% {
	        opacity: 1;
	        transform: scale(1);
	        box-shadow: 0 0 10px var(--clearing-color), 0 0 20px var(--clearing-color);
	        border: none; /* Garante que a borda n√£o apare√ßa no in√≠cio da anima√ß√£o */
	      }
      100% {
        opacity: 0;
        transform: scale(1.2);
        box-shadow: 0 0 30px var(--clearing-color), 0 0 60px var(--clearing-color);
      }
    }

.blocks-container {
	      background: rgba(255, 255, 255, 0.2); /* 20% de opacidade */
	      backdrop-filter: blur(10px); /* Mantendo o blur aqui */
	      border: 3px solid rgba(255, 255, 255, 0.3);
	      border-radius: 15px;
	      padding: 10px; /* Reduzido para melhor visualiza√ß√£o dos blocos */
	      margin-bottom: 10px;
	    }

    .blocks-label {
      font-size: 0.9rem;
      opacity: 0.8;
	      margin-bottom: 5px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

	    .blocks-grid {
	      display: flex;
	      justify-content: center;
	      gap: 15px;
	      flex-wrap: wrap;
	      align-items: center; /* Adicionado para alinhar verticalmente */
	    }

	    .draggable-block {
	      cursor: grab;
	      user-select: none;
	      transition: transform 0.2s; /* Apenas a transi√ß√£o do transform para o hover */
	      padding: 5px;
	      background: transparent; /* Removido o fundo */
	      border-radius: 10px;
	      border: 2px solid transparent; /* Removido a borda */
	    }

	    .draggable-block:hover {
	      transform: scale(1.05);
	      background: transparent; /* Removido o fundo */
	    }

    .draggable-block:active {
      cursor: grabbing;
    }

    .draggable-block.dragging {
      opacity: 0;
    }

    .block-grid {
      display: grid;
      gap: 2px; /* Reduzido o gap para dar a sensa√ß√£o de blocos mais conectados */
      grid-template-columns: repeat(auto-fit, minmax(30px, 1fr));
    }

	    .block-cell {
	      width: 30px;
	      height: 30px;
	      border-radius: 5px;
	      border: 2px solid rgba(0, 0, 0, 0.3);
	    }

    .controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 20px;
    }

    button {
      padding: 12px 20px;
      border: none;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      cursor: pointer;
      font-size: 1rem;
      font-weight: bold;
      transition: all 0.3s;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    button:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

		    .info-text {
		      font-size: 0.8rem;
	      background: linear-gradient(to right, #4169E1, #4B0082);
	      -webkit-background-clip: text;
	      -webkit-text-fill-color: transparent;
	      text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
	      font-weight: bold;
	      margin-top: 10px;
	    }

    .menu-screen {
      display: block;
    }

    .menu-screen.hidden {
      display: none;
    }

    .game-screen {
      display: none;
    }

.game-screen.show {
	      display: block;
	    }
	
	    /* Estilos espec√≠ficos para o menu */
	    #menuScreen.container {
	      background: rgba(255, 255, 255, 0.2); /* 20% de opacidade */
	      backdrop-filter: blur(10px);
	      border: 2px solid white;
	    }

    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }

    .modal.hidden {
      display: none !important;
    }

    .settings-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }

    .settings-modal.hidden {
      display: none !important;
    }

    .settings-content {
      background: transparent;
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      max-width: 400px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
    }

	    .settings-content h2 {
	      font-size: 2rem;
	      margin-bottom: 30px;
	      color: #FFD700;
	    }
	
	    /* Estilos do Player de M√∫sica */
	    .music-player {
	      width: 100%;
	      padding: 20px 0;
	      border-radius: 15px;
	      background: rgba(0, 0, 0, 0.3);
	      margin-bottom: 20px;
	    }
	
	    .music-title {
	      font-size: 1.2rem;
	      font-weight: bold;
	      color: #4ECDC4;
	      margin-bottom: 15px;
	    }
	
	    .progress-container {
	      display: flex;
	      align-items: center;
	      gap: 10px;
	      margin-bottom: 20px;
	    }
	
	    .progress-bar {
	      flex-grow: 1;
	      height: 8px;
	      background: rgba(255, 255, 255, 0.3);
	      border-radius: 4px;
	      cursor: pointer;
	      position: relative;
	    }

	    .progress-fill {
	      height: 100%;
	      width: 0%;
	      background: #4ECDC4;
	      border-radius: 4px;
	    }
	
	    .time-display {
	      font-size: 0.9rem;
	      color: rgba(255, 255, 255, 0.7);
	      width: 40px;
	      text-align: right;
	    }
	
	    .controls-container {
	      display: flex;
	      justify-content: center;
	      align-items: center;
	      gap: 20px;
	    }
	
	    .control-btn {
	      background: rgba(255, 255, 255, 0.1);
	      border: 2px solid rgba(255, 255, 255, 0.3);
	      color: white;
	      font-size: 1.5rem;
	      width: 50px;
	      height: 50px;
	      border-radius: 50%;
	      display: flex;
	      align-items: center;
	      justify-content: center;
	      cursor: pointer;
	      transition: all 0.2s;
	    }

	    .control-btn:hover {
	      background: rgba(255, 255, 255, 0.2);
	      transform: scale(1.05);
	    }

	    .control-btn.main:hover {
	      background: #5ed8ce;
	      border-color: #5ed8ce;
	    }

    .setting-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    .setting-item label {
      font-size: 1.1rem;
      font-weight: bold;
      color: white;
    }

    .toggle-switch {
      position: relative;
      width: 60px;
      height: 30px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      cursor: pointer;
      border: 2px solid rgba(255, 255, 255, 0.3);
      transition: all 0.3s;
    }

    .toggle-switch.active {
      background: #00FF00;
    }

    .toggle-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 24px;
      height: 24px;
      background: white;
      border-radius: 50%;
      transition: left 0.3s;
    }

    .toggle-switch.active .toggle-slider {
      left: 32px;
    }

    .settings-content button {
      width: 100%;
      margin-top: 20px;
      padding: 15px;
      font-size: 1.1rem;
    }

	body.dark-mode::before {
				      filter: brightness(50%); /* Diminui o brilho em 50% */
				    }
	
	body.dark-mode .container {
		      background: transparent; /* Padr√£o sem fundo */
		    }
	
	    body.dark-mode .game-board {
	      background: #0a1428;
	      border-color: rgba(255, 255, 255, 0.2);
	    }
	
	    body.dark-mode .cell {
	      background: rgba(0, 0, 0, 0.5);
	      border-color: rgba(255, 255, 255, 0.1);
	    }
	
	    body.dark-mode .cell:hover {
	      background: rgba(255, 255, 255, 0.05);
	    }
	
	    .modal-content {
	      background: transparent;
	      padding: 40px;
	      border-radius: 20px;
	      text-align: center;
	      max-width: 400px;
	      border: 3px solid rgba(255, 255, 255, 0.3);
	      box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
	    }
	
	    .modal-content h2 {
	      font-size: 2.5rem;
	      margin-bottom: 20px;
	      color: #FFD700;
	    }
	
	    .modal-content p {
	      font-size: 1.3rem;
	      margin-bottom: 20px;
	      color: #00ff00;
	    }
	
	    .modal-content button {
	      width: 100%;
	      margin: 10px 0;
	      padding: 15px;
	      font-size: 1.1rem;
	    }
	
	h1 {
		      font-size: 2rem; /* Reduzindo o tamanho da fonte */
		      margin-bottom: 15px; /* Reduzindo a margem */
		      text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
		      white-space: nowrap; /* Tentando manter na mesma linha */
		    }
	
	    .menu-screen button {
	      width: 100%;
	      padding: 20px;
	      font-size: 1.3rem;
	      margin-top: 20px;
	    }
	
	    .relaxing-text {
	      font-size: 1.5rem;
	      color: #00ff00;
	      font-weight: bold;
	      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	      margin-top: 20px;
	    }
	
	    .combo-animation {
	      position: fixed;
	      font-size: 2rem;
	      font-weight: bold;
	      color: var(--combo-color, #FFD700); /* Usar vari√°vel CSS para cor */
	      pointer-events: none;
	      animation: floatUp 1s ease-out forwards;
	      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	    }
	
	    @keyframes floatUp {
	      0% {
	        opacity: 1;
	        transform: translateY(0) scale(1);
	      }
	      100% {
	        opacity: 0;
	        transform: translateY(-80px) scale(0.5);
	      }
	    }
	  </style>
	</head>
	<body>
	  <button id="backToSiteBtn">
	    <span class="arrow">‚Üê</span>
	    <span class="text">Voltar</span>
	  </button>
	
	  <div id="menuScreen" class="container menu-screen">
	    <h1 style="display: flex; align-items: center; justify-content: center; gap: 10px;">üéÆ BLOCK BLAST</h1>
	    <p style="font-size: 1.2rem; margin-bottom: 30px; opacity: 0.9;">Arraste os blocos e complete as linhas!</p>
	    <button onclick="startGame()" style="width: 100%; padding: 20px; font-size: 1.3rem;">Come√ßar Jogo</button>
	  </div>
	
	  <div id="gameScreen" class="container game-screen">
	    <div class="header">
	      <div class="score-display" id="scoreDisplay">0</div>
	      <button class="settings-btn" onclick="openSettings()">‚öôÔ∏è</button>
	    </div>
	
	    <div class="game-board" id="gameBoard"></div>
	
	    <div class="blocks-container">
	      <div class="blocks-label">Pr√≥ximos Blocos</div>
	      <div class="blocks-grid" id="blocksGrid"></div>
	    </div>
	
		    <div class="controls">
		      <button onclick="resetGame()">üîÑ Reiniciar Jogo</button>
		    </div>
	
		    <div class="info-text" id="infoText">YXS</div>
	  </div>
	
	  <div id="settingsModal" class="settings-modal hidden" onclick="closeSettings()">
	    <div class="settings-content" onclick="event.stopPropagation()">
	      <h2>‚öôÔ∏è Configura√ß√µes</h2>
	      
	      <div class="setting-item">
	        <label>Som</label>
	        <div class="toggle-switch" id="soundToggle" onclick="toggleSound()">
	          <div class="toggle-slider"></div>
	        </div>
	      </div>
	
	      <div class="music-player">
	        <div class="music-title" id="playerMusicTitle">Champagne Coast</div>
	        
	        <div class="progress-container">
	          <span class="time-display" id="currentTimeDisplay">0:00</span>
		      <div class="progress-bar" id="progressBar" onmousedown="seekToPosition(event)" ontouchstart="seekToPosition(event)">
		            <div class="progress-fill" id="progressFill"></div>
		          </div>
	          <span class="time-display" id="durationDisplay">0:00</span>
	        </div>
	
	        <div class="controls-container">
	          <div class="control-btn" onclick="seekMusic(-10)">¬´ 10</div>
	          <div class="control-btn main" id="playPauseBtn" onclick="togglePlayPause()">
	            <span id="playPauseIcon">‚ùö‚ùö</span>
	          </div>
	          <div class="control-btn" onclick="seekMusic(10)">10 ¬ª</div>
	        </div>
	      </div>
	
	      <div class="setting-item">
	        <label>Modo Escuro</label>
	        <div class="toggle-switch" id="darkModeToggle" onclick="toggleDarkMode()">
	          <div class="toggle-slider"></div>
	        </div>
	      </div>
	
	      <button onclick="closeSettings()">Fechar</button>
	    </div>
	  </div>
	
	  <div id="gameOverModal" class="modal hidden">
	    <div class="modal-content">
	      <h2>Game Over!</h2>
	      <p>Pontua√ß√£o Final: <span id="finalScore" style="color: #FFD700;">0</span></p>
	      <button onclick="resetGame()">Jogar Novamente</button>
	      <button onclick="goToMenu()">Menu Principal</button>
	    </div>
	  </div>
	
	  <audio id="audioWow" src="wow.mp3" preload="auto"></audio>
	  <audio id="audioAmazing" src="amazing.mp3" preload="auto"></audio>
		  <audio id="audioFantastic" src="fantastic.mp3" preload="auto"></audio>
		  <audio id="audioBackground1" src="musica1.mp3" preload="auto"></audio>
		  <audio id="audioBackground2" src="musica2.mp3" preload="auto"></audio>
		  <audio id="audioBackground3" src="musica3.mp3" preload="auto"></audio>
	  <audio id="audioPop" src="pop.mp3" preload="auto"></audio>
	
		  <script>
		    
		    // --- Fun√ß√µes de Player de M√∫sica ---
		    
		    function formatTime(seconds) {
		      if (isNaN(seconds)) return '0:00';
		      const minutes = Math.floor(seconds / 60);
		      const remainingSeconds = Math.floor(seconds % 60);
		      return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
		    }
		
		    function getCurrentAudio() {
		      // O index agora √© baseado no array MUSIC_LIST (0, 1, 2)
		      // O ID do elemento de √°udio ainda √© baseado em 1 (audioBackground1, audioBackground2, etc.)
		      return document.getElementById(`audioBackground${currentMusicIndex + 1}`);
		    }
		
		    function togglePlayPause() {
		      const audio = getCurrentAudio();
		      const icon = document.getElementById('playPauseIcon');
		      if (!audio || !gameState.soundEnabled) {
		        // Se o som estiver desativado ou nenhum √°udio estiver carregado, n√£o podemos tocar/pausar
		        return;
		      }
		
		      if (audio.paused) {
		        audio.play().catch(e => console.error("Erro ao reproduzir m√∫sica:", e));
		        icon.textContent = '‚ùö‚ùö'; // √çcone de Pausa
		      } else {
		        audio.pause();
		        icon.textContent = '‚ñ∂'; // √çcone de Play
		      }
		    }
		
		    function seekMusic(seconds) {
		      const audio = getCurrentAudio();
		      if (audio) {
		        audio.currentTime += seconds;
		      }
		    }
		
		    function seekToPosition(e) {
		      // Previne o comportamento padr√£o do navegador para evitar rolagem e outros problemas
		      e.preventDefault();
		      
		      const audio = getCurrentAudio();
		      const progressBarContainer = document.getElementById('progressBar');
		      if (!audio || !progressBarContainer || audio.readyState < 2) return;
		
		      const rect = progressBarContainer.getBoundingClientRect();
		      // Usa clientX para mouse ou o primeiro touch point para touch
		      const clickX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : undefined);
		      if (clickX === undefined) return;
		      
		      const percentage = (clickX - rect.left) / rect.width;
		      
		      // Garante que o tempo n√£o seja negativo ou maior que a dura√ß√£o
		      audio.currentTime = Math.max(0, Math.min(audio.duration, audio.duration * percentage));
		      
		      // For√ßa a atualiza√ß√£o imediata da barra de progresso
		      updateProgressBar();
		    }
		
		    function updateProgressBar() {
		      const audio = getCurrentAudio();
		      const progressBar = document.getElementById('progressFill');
		      const currentTimeDisplay = document.getElementById('currentTimeDisplay');
		      const durationDisplay = document.getElementById('durationDisplay');
		      const playPauseIcon = document.getElementById('playPauseIcon');
		      const musicTitle = document.getElementById('playerMusicTitle');
		
		      if (audio && audio.readyState >= 2) { // Verifica se o √°udio est√° pronto para reprodu√ß√£o
		        // Atualiza barra de progresso
		        const percentage = (audio.currentTime / audio.duration) * 100;
		        progressBar.style.width = `${percentage}%`;
		
		        // Atualiza displays de tempo
		        currentTimeDisplay.textContent = formatTime(audio.currentTime);
		        durationDisplay.textContent = formatTime(audio.duration);
		
		        // Atualiza √≠cone de play/pause
		        playPauseIcon.textContent = audio.paused ? '‚ñ∂' : '‚ùö‚ùö';
		        
		        // Atualiza t√≠tulo da m√∫sica
		        musicTitle.textContent = MUSIC_LIST[currentMusicIndex].name;
		      } else {
		        // Reset displays se nenhum √°udio estiver pronto
		        progressBar.style.width = '0%';
		        currentTimeDisplay.textContent = '0:00';
		        durationDisplay.textContent = '0:00';
		        playPauseIcon.textContent = '‚ñ∂';
		        musicTitle.textContent = 'Nenhuma M√∫sica';
		      }
		    }
		
		    // --- Fim Fun√ß√µes de Player de M√∫sica ---
		
		    function playSound(audioId) {
	      if (audioId === 'audioPop') {
	        // Para o pop, usamos um volume mais baixo para n√£o competir com a m√∫sica de fundo
	        // e n√£o clonamos, pois ele √© um som r√°pido e pode ser reproduzido v√°rias vezes.
	        // Se o usu√°rio quiser o pop em todos os cliques, ele deve ser r√°pido.
	        const audio = document.getElementById(audioId);
	        if (audio && gameState.soundEnabled) {
	          audio.currentTime = 0;
	          audio.volume = 0.3;
	          audio.play().catch(e => console.error("Erro ao reproduzir √°udio:", e));
	        }
	        return;
	      }
	
	
	      if (gameState.soundEnabled) {
	        const audio = document.getElementById(audioId);
	        if (audio) {
	          // Clonar o n√≥ de √°udio para permitir que o som seja reproduzido
	          // v√°rias vezes rapidamente sem atraso (solu√ß√£o para o atraso do WOW)
	          const clone = audio.cloneNode();
	          clone.volume = 0.5; // Ajustar volume para evitar estouro
	          clone.play().catch(e => console.error("Erro ao reproduzir √°udio:", e));
	        }
	      }
	    }
	
			    const MUSIC_LIST = [
			      { name: "Champagne Coast", file: "musica1.mp3" },
			      { name: "Dreamin", file: "musica2.mp3" },
			      { name: "Get You", file: "musica3.mp3" }
			    ];
			    let currentMusicIndex = 0; // √çndice 0 para Champagne Coast
			    const MAX_MUSIC_INDEX = MUSIC_LIST.length - 1;
		
			    function playNextMusic() {
			      const currentAudio = getCurrentAudio();
			      if (currentAudio) {
			        currentAudio.pause();
			        currentAudio.currentTime = 0;
			      }
			
			      currentMusicIndex = (currentMusicIndex + 1) % MUSIC_LIST.length;
			
			      const nextAudio = getCurrentAudio();
			      if (nextAudio && gameState.soundEnabled) {
			        nextAudio.volume = 0.6;
			        nextAudio.play().catch(e => console.error("Erro ao reproduzir m√∫sica de fundo:", e));
			        nextAudio.onended = playNextMusic; // Configura o loop para a pr√≥xima m√∫sica
	
			      }
			    }
			
			    function toggleBackgroundMusic(play) {
			      if (play && gameState.soundEnabled) {
			        const currentAudio = getCurrentAudio();
			        if (currentAudio && currentAudio.paused) {
			          currentAudio.volume = 0.6;
			          currentAudio.play().catch(e => console.error("Erro ao reproduzir m√∫sica de fundo:", e));
			          currentAudio.onended = playNextMusic;
	
			        } else if (!currentAudio) {
			          // Inicia a primeira m√∫sica se nenhuma estiver tocando
			          currentMusicIndex = 0;
			          const firstAudio = getCurrentAudio();
			          if (firstAudio) {
			            firstAudio.volume = 0.6;
			            firstAudio.play().catch(e => console.error("Erro ao reproduzir m√∫sica de fundo:", e));
			            firstAudio.onended = playNextMusic;
	
			          }
			        }
			      } else {
			        // Pausa todas as m√∫sicas
			        for (let i = 0; i < MUSIC_LIST.length; i++) {
			          const audio = document.getElementById(`audioBackground${i + 1}`);
			          if (audio) {
			            audio.pause();
			          }
			        }
			      }
			    }
	
	
	    const BOARD_SIZE = 6;
	    const NUM_STARTING_BLOCKS = 3; // Mantido para refer√™ncia
	    const COLORS = [
	      '#FF3333', '#00CED1', '#1E90FF', '#FF6347', '#3CB371',
	      '#FFD700', '#9932CC', '#4169E1', '#FF8C00', '#00FA9A',
	      '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF'
	    ];
	
	    const BLOCK_SHAPES = [
	      { shape: [[1]], name: '1x1' },
	      { shape: [[1, 1]], name: '1x2' },
	      { shape: [[1], [1]], name: '2x1' },
	      { shape: [[1, 1], [1, 1]], name: '2x2' },
	      { shape: [[1, 1, 1]], name: '1x3' },
	      { shape: [[1], [1], [1]], name: '3x1' },
	      { shape: [[1, 0], [1, 1]], name: 'L' },
	      { shape: [[0, 1], [1, 1]], name: 'L2' },
	      { shape: [[1, 1, 1, 1]], name: '1x4' }
	    ];
	
	    let gameState = {
	      board: [],
	      score: 0,
		      level: 0,
	      blocks: [],
	      gameActive: false,
	      draggedBlock: null,
	      previewRow: null,
	      previewCol: null,
	      darkMode: false,
	      soundEnabled: true
	    };
	
	    function initGame() {
	      gameState.board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(0));
	      gameState.score = 0;
		      // gameState.level = 0; // Removido por solicita√ß√£o do usu√°rio
	      gameState.gameActive = true;
	      gameState.blocks = generateBlocks(NUM_STARTING_BLOCKS); // Gera 3 blocos iniciais
	
	      renderBoard();
	      renderBlocks();
	      updateDisplay();
	    }
	
	    function startGame() {
	      playSound('audioPop');
	      document.getElementById('menuScreen').classList.add('hidden');
	      document.getElementById('gameScreen').classList.add('show');
	      document.getElementById('gameOverModal').classList.add('hidden');
	      document.getElementById('settingsModal').classList.add('hidden');
	      initToggles();
	      initGame();
	      toggleBackgroundMusic(true);
	    }
	
	    function goToMenu() {
	      playSound('audioPop');
	      document.getElementById('menuScreen').classList.remove('hidden');
	      document.getElementById('gameScreen').classList.remove('show');
	      document.getElementById('gameOverModal').classList.add('hidden');
	      document.getElementById('settingsModal').classList.add('hidden');
	      gameState.gameActive = false;
	      toggleBackgroundMusic(false);
	    }
	
	    function resetGame() {
	      playSound('audioPop');
	      startGame();
	    }
	
	    function generateBlocks(count) {
	      const blocks = [];
	      for (let i = 0; i < count; i++) {
	        const shapeObj = BLOCK_SHAPES[Math.floor(Math.random() * BLOCK_SHAPES.length)];
	        const color = COLORS[Math.floor(Math.random() * COLORS.length)];
	        blocks.push({
	          id: Math.random(),
	          shape: shapeObj.shape,
	          color: color,
	          name: shapeObj.name
	        });
	      }
	      return blocks;
	    }
	
	    function renderBoard() {
	      const boardElement = document.getElementById('gameBoard');
	      boardElement.innerHTML = '';
	
	      for (let row = 0; row < BOARD_SIZE; row++) {
	        for (let col = 0; col < BOARD_SIZE; col++) {
	          const cell = document.createElement('div');
	          cell.className = 'cell';
	          cell.id = `cell-${row}-${col}`;
	          cell.dataset.row = row;
	          cell.dataset.col = col;
	
	          if (gameState.board[row][col] !== 0) {
	            cell.classList.add('filled');
	            cell.style.background = gameState.board[row][col];
	          }
	
	          boardElement.appendChild(cell);
	        }
	      }
	    }
	
		    function showPreview(startRow, startCol) {
		      // Limpar preview anterior
		      const allCells = document.querySelectorAll('.cell');
		      allCells.forEach(cell => {
		        // Limpar o background e a classe 'filled' apenas se a c√©lula n√£o estiver preenchida no tabuleiro
		        if (cell.classList.contains('preview')) {
		          cell.classList.remove('preview');
		          if (gameState.board[cell.dataset.row][cell.dataset.col] === 0) {
		            cell.style.background = '';
		            cell.style.borderColor = '';
		            cell.style.opacity = '';
		          }
		        }
		        if (cell.classList.contains('clearing-preview')) {
		          cell.classList.remove('clearing-preview');
		          if (gameState.board[cell.dataset.row][cell.dataset.col] === 0) {
		            cell.style.background = '';
		            cell.style.borderColor = '';
		            cell.style.opacity = '';
		          }
		        }
		      });
		      
		      if (!gameState.draggedBlock) return;
		
		      const block = gameState.draggedBlock.block;
		      const shape = block.shape;
		      const shapeRows = shape.length;
		      const shapeCols = shape[0].length;
		
		      // Verificar se cabe
		      // Esta verifica√ß√£o √© redundante se a fun√ß√£o 'drag' usou a nova l√≥gica, mas √© mantida por seguran√ßa.
		      if (startRow + shapeRows > BOARD_SIZE || startCol + shapeCols > BOARD_SIZE || startRow < 0 || startCol < 0) {
		        gameState.previewRow = null;
		        gameState.previewCol = null;
		        return;
		      }
		
		      // Verificar se as c√©lulas est√£o vazias
		      let canPlace = true;
		      for (let r = 0; r < shapeRows; r++) {
		        for (let c = 0; c < shapeCols; c++) {
		          if (shape[r][c] === 1) {
		            if (gameState.board[startRow + r][startCol + c] !== 0) {
		              canPlace = false;
		              break;
		            }
		          }
		        }
		        if (!canPlace) break;
		      }
		
		      if (!canPlace) {
		        gameState.previewRow = null;
		        gameState.previewCol = null;
		        return;
		      }
		
		      // Salvar a posi√ß√£o de in√≠cio calculada para uso no drop
		      gameState.previewRow = startRow;
		      gameState.previewCol = startCol;
		      
		      // 1. Mostrar preview (Ghost Block)
		      for (let r = 0; r < shapeRows; r++) {
		        for (let c = 0; c < shapeCols; c++) {
		          if (shape[r][c] === 1) {
		            const cellId = `cell-${startRow + r}-${startCol + c}`;
		            const cell = document.getElementById(cellId);
		            if (cell) {
		              cell.classList.add('preview');
		              cell.style.background = block.color;
		              cell.style.setProperty('--preview-color', block.color);
		            }
		          }
		        }
		      }
		      
		      // 2. Verificar se a coloca√ß√£o ir√° limpar linhas/colunas (Efeito "Linha Cheia")
		      const linesToClear = checkIfPlacingClearsLines(startRow, startCol, block.shape);
		      
		      if (linesToClear.length > 0) {
		        linesToClear.forEach(line => {
		          if (line.type === 'row') {
		            for (let col = 0; col < BOARD_SIZE; col++) {
		              const cell = document.getElementById(`cell-${line.index}-${col}`);
		              if (cell) {
		                cell.classList.add('clearing-preview');
		                cell.style.setProperty('--preview-color', block.color);
		              }
		            }
		          } else { // col
		            for (let row = 0; row < BOARD_SIZE; row++) {
		              const cell = document.getElementById(`cell-${row}-${line.index}`);
		              if (cell) {
		                cell.classList.add('clearing-preview');
		                cell.style.setProperty('--preview-color', block.color);
		              }
		            }
		          }
		        });
		      }
		    }
	
		    function checkIfPlacingClearsLines(startRow, startCol, shape) {
		      // Cria uma c√≥pia tempor√°ria do tabuleiro para simular a coloca√ß√£o
		      const tempBoard = gameState.board.map(row => [...row]);
		      const shapeRows = shape.length;
		      const shapeCols = shape[0].length;
		      
		      // Simula a coloca√ß√£o do bloco
		      for (let r = 0; r < shapeRows; r++) {
		        for (let c = 0; c < shapeCols; c++) {
		          if (shape[r][c] === 1) {
		            tempBoard[startRow + r][startCol + c] = 1; // 1 √© o suficiente para marcar como preenchido
		          }
		        }
		      }
		      
		      let linesToClear = [];
		      
		      // Verifica linhas
		      for (let row = 0; row < BOARD_SIZE; row++) {
		        if (tempBoard[row].every(cell => cell !== 0)) {
		          linesToClear.push({ type: 'row', index: row });
		        }
		      }
		      
		      // Verifica colunas
		      for (let col = 0; col < BOARD_SIZE; col++) {
		        if (tempBoard.every(row => row[col] !== 0)) {
		          // Verifica se a coluna j√° foi coberta por uma linha (para evitar duplicidade)
		          let isCoveredByRow = linesToClear.some(l => l.type === 'row' && l.index === col);
		          if (!isCoveredByRow) { // Simplificada a verifica√ß√£o, mas funciona para evitar duplica√ß√£o em linhas horizontais/verticais
		            linesToClear.push({ type: 'col', index: col });
		          }
		        }
		      }
		      
		      return linesToClear;
		    }
	
		    function clearPreview() {
		      const allCells = document.querySelectorAll('.cell');
		      allCells.forEach(cell => {
		        // Limpar o background e a classe 'filled' apenas se a c√©lula n√£o estiver preenchida no tabuleiro
		        if (cell.classList.contains('preview') || cell.classList.contains('clearing-preview')) {
		          cell.classList.remove('preview');
		          cell.classList.remove('clearing-preview');
		          
		          // Apenas limpa o estilo se a c√©lula estiver vazia no tabuleiro
		          if (gameState.board[cell.dataset.row][cell.dataset.col] === 0) {
		            cell.style.background = '';
		            cell.style.borderColor = '';
		            cell.style.opacity = '';
		          }
		        }
		      });
		    }
		
		    // --- Fun√ß√µes de Drag Customizado ---
		
	function getEventCoords(e) {
			      // Para eventos de toque, use o primeiro ponto de toque em `touches` (para start/move)
			      // ou `changedTouches` (para end). Usando clientX/Y para garantir coordenadas do viewport.
			      if (e.touches && e.touches.length > 0) {
			        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
			      } else if (e.changedTouches && e.changedTouches.length > 0) {
			        return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
			      }
			      // Para eventos de mouse, use clientX/clientY diretamente.
			      return { x: e.clientX, y: e.clientY };
			    }
		
		    function getCellUnderCoords(x, y) {
		      const element = document.elementFromPoint(x, y);
		      if (element && element.classList.contains('cell')) {
		        return element;
		      }
		      return null;
		    }
		
	function startDrag(e) {
			      // Previne o comportamento padr√£o do navegador para evitar rolagem e outros problemas
			      e.preventDefault();
			      e.stopPropagation();
			      if (e.button === 2) return; // Ignora clique com o bot√£o direito
		
		      const blockDiv = e.currentTarget;
		      const blockId = blockDiv.id.split('-')[1];
		      const blockIndex = gameState.blocks.findIndex(b => b.id == blockId);
		
		      if (blockIndex === -1) return;
		
		      currentBlockElement = blockDiv;
		      currentBlockIndex = blockIndex;
		      currentBlockData = gameState.blocks[blockIndex];
		
		      // 1. Criar e configurar o bloco flutuante
		      const floatingBlock = document.createElement('div');
		      floatingBlock.id = 'floating-block';
		      // Copiar a estrutura do bloco arrastado, mas sem a classe 'draggable-block'
		      floatingBlock.innerHTML = blockDiv.querySelector('.block-grid').outerHTML;
		      
		      // Estilos para o bloco flutuante (posi√ß√£o absoluta e z-index alto)
		      floatingBlock.style.position = 'fixed';
		      floatingBlock.style.zIndex = '1000';
		      floatingBlock.style.pointerEvents = 'none'; // N√£o deve interferir no hit-test
		      floatingBlock.style.opacity = '0.9';
		      floatingBlock.style.transform = 'scale(1.2)'; // Aumenta um pouco para destacar
		
		      document.body.appendChild(floatingBlock);
		
		      // 2. Ocultar o bloco original
		      blockDiv.classList.add('dragging');
		
		      // 3. Configurar o estado de drag
		      gameState.draggedBlock = {
		        block: currentBlockData,
		        element: floatingBlock,
		        originalElement: blockDiv
		      };
		
		      // 4. Calcular o tamanho do bloco flutuante (apenas uma vez)
		      const rect = floatingBlock.getBoundingClientRect();
		      blockHalfWidth = rect.width / 2;
		      blockHalfHeight = rect.height / 2;
		
		      // 5. Inicializar coordenadas
		      const coords = getEventCoords(e);
		      targetX = coords.x;
		      targetY = coords.y;
		
		      // 6. Iniciar a anima√ß√£o
		      // O movimento real √© feito dentro do requestAnimationFrame
		      rAF_id = requestAnimationFrame(animateFloatingBlock);
		
		      // 7. Adicionar listeners para o movimento e fim do drag
		      document.addEventListener('mousemove', drag, { passive: false });
		      document.addEventListener('touchmove', drag, { passive: false });
		      document.addEventListener('mouseup', endDrag);
		      document.addEventListener('touchend', endDrag);
		      
		      // Chamada imediata para que o preview apare√ßa
		      drag(e); 
		    }
		
		    // Vari√°veis globais para o drag customizado
		    let currentBlockElement = null;
		    let currentBlockIndex = -1;
		    let currentBlockData = null;
		    let targetX = 0;
		    let targetY = 0;
		    let rAF_id = null;
		    let lastPreviewCell = null;
		
		    // CORRE√á√ÉO PARA O SNAP (Snapping e Offset de arrasto)
		    // Aumentado de -50 para -120 para que o bloco fique "bem longe" do dedo
		    const DRAG_Y_OFFSET = -120; 
		    let blockHalfWidth = 0; 
		    let blockHalfHeight = 0; 
		
		    function animateFloatingBlock() {
		      const floatingBlock = document.getElementById('floating-block');
		      if (floatingBlock) {
		        // Movimento Direto: Lat√™ncia zero
		        floatingBlock.style.left = `${targetX - blockHalfWidth}px`;
		        // Adicionando offset vertical para manter o bloco acima do dedo
		        floatingBlock.style.top = `${targetY - blockHalfHeight + DRAG_Y_OFFSET}px`; 
		      }
		      rAF_id = requestAnimationFrame(animateFloatingBlock);
		    }
		
	function drag(e) {
		      if (!gameState.draggedBlock) return;
		      // O preventDefault √© importante para evitar a rolagem da p√°gina em dispositivos touch
		      e.preventDefault(); 
		      e.stopPropagation(); // Adicionado para evitar propaga√ß√£o do evento
		
		      const coords = getEventCoords(e);
		      // Apenas atualiza as coordenadas alvo. O movimento √© feito no rAF.
		      targetX = coords.x;
		      targetY = coords.y;
		      
		      // L√≥gica de Preview/Drop no evento de movimento.
		      // 1. Calcular o centro real do bloco flutuante
		      const floating = document.getElementById('floating-block');
		      let cell = null;
		      let centerX = 0;
		      let centerY = 0;
		      
		      if (floating) {
		        const rect = floating.getBoundingClientRect();
		        centerX = rect.left + rect.width / 2;
		        centerY = rect.top + rect.height / 2;
		        // Tenta pegar a c√©lula sob o centro do bloco (ou pr√≥ximo dele)
		        cell = getCellUnderCoords(centerX, centerY);
		        // Se n√£o encontrar (por causa de z-index), tenta com um pequeno ajuste vertical
		        if (!cell) {
		          cell = getCellUnderCoords(centerX, centerY - 5) || getCellUnderCoords(centerX, centerY + 5);
		        }
		      } else {
		        // Fallback: usa posi√ß√£o do dedo
		        cell = getCellUnderCoords(targetX, targetY);
		      }
		
		      let best = {cell: cell, dist: Infinity, r: -1, c: -1};
		        
		      // 2. Snapping Forte (√çM√É): procurar a c√©lula cuja *posi√ß√£o central* est√° mais pr√≥xima do *centro do bloco flutuante*.
		      if (floating && cell) {
		        const hoverRow = parseInt(cell.dataset.row);
		        const hoverCol = parseInt(cell.dataset.col);
		          
		        // Busca em uma √°rea de 3x3 ao redor da c√©lula atual para encontrar o melhor alvo de "√≠m√£"
		        for (let r = Math.max(0, hoverRow-1); r <= Math.min(BOARD_SIZE-1, hoverRow+1); r++) {
		          for (let c = Math.max(0, hoverCol-1); c <= Math.min(BOARD_SIZE-1, hoverCol+1); c++) {
		            const candidate = document.getElementById(`cell-${r}-${c}`);
		            if (!candidate) continue;
		            const crect = candidate.getBoundingClientRect();
		            const ccx = crect.left + crect.width/2;
		            const ccy = crect.top + crect.height/2;
		              
		            // Dist√¢ncia entre o CENTRO DO BLOCO e o CENTRO DA C√âLULA CANDIDATA
		            const d = Math.hypot(centerX-ccx, centerY-ccy);
		              
		            if (d < best.dist) {
		              best = {cell: candidate, dist: d, r: r, c: c};
		            }
		          }
		        }
		        cell = best.cell; // A c√©lula mais pr√≥xima do centro do bloco √© a nova c√©lula alvo
		      }
		
		
		      if (cell) {
		        // Se a c√©lula alvo for diferente da √∫ltima ou se for a primeira vez, atualiza
		        if (cell !== lastPreviewCell || lastPreviewCell === null) {
		          lastPreviewCell = cell;
		
		          const finalHoverRow = parseInt(cell.dataset.row);
		          const finalHoverCol = parseInt(cell.dataset.col);
		
		          const block = gameState.draggedBlock.block;
		          const shape = block.shape;
		          const shapeRows = shape.length;
		          const shapeCols = shape[0].length;
		          
		          // 1. Calcular o ponto de in√≠cio ideal (centrado) - S√ì para calcular a proximidade.
		          const idealRowStart = finalHoverRow - Math.floor(shapeRows / 2);
		          const idealColStart = finalHoverCol - Math.floor(shapeCols / 2);
		
		          let bestStartRow = null;
		          let bestStartCol = null;
		          let minDistance = Infinity;
		
		          // 2. Procurar o melhor ponto de in√≠cio V√ÅLIDO que COBRE a c√©lula alvo (finalHoverRow, finalHoverCol)
		          
		          // Range de busca para as linhas (startRow)
		          const maxRowStart = Math.min(BOARD_SIZE - shapeRows, finalHoverRow);
		          const minRowStart = Math.max(0, finalHoverRow - shapeRows + 1);
		          
		          // Range de busca para as colunas (startCol)
		          const maxColStart = Math.min(BOARD_SIZE - shapeCols, finalHoverCol);
		          const minColStart = Math.max(0, finalHoverCol - shapeCols + 1);
		
		
		          for (let r = minRowStart; r <= maxRowStart; r++) {
		            for (let c = minColStart; c <= maxColStart; c++) {
		              
		              // 3. Verificar se este ponto de in√≠cio √© V√ÅLIDO (cabe e n√£o colide)
		              if (canPlace(r, c, shape)) {
		                // 4. Calcular a dist√¢ncia deste ponto v√°lido para o ponto ideal (centrado)
		                const distance = Math.hypot(r - idealRowStart, c - idealColStart);
		
		                // 5. Se for o mais pr√≥ximo at√© agora
		                if (distance < minDistance) {
		                  minDistance = distance;
		                  bestStartRow = r;
		                  bestStartCol = c;
		                }
		              }
		            }
		          }
		
		          // 6. Mostrar preview na melhor posi√ß√£o encontrada
		          if (bestStartRow !== null) {
		            showPreview(bestStartRow, bestStartCol);
		          } else {
		            // Nenhuma posi√ß√£o v√°lida cobrindo a c√©lula alvo foi encontrada
		            gameState.previewRow = null;
		            gameState.previewCol = null;
		            clearPreview();
		          }
		
		        }
		
		      } else if (!cell && lastPreviewCell) {
		        // Se saiu do tabuleiro, limpa o preview
		        lastPreviewCell = null;
		        clearPreview();
		        gameState.previewRow = null;
		        gameState.previewCol = null;
		      }
		    }
		
		    function endDrag() {
		      cancelAnimationFrame(rAF_id);
		      
		      document.removeEventListener('mousemove', drag);
		      document.removeEventListener('touchmove', drag);
		      document.removeEventListener('mouseup', endDrag);
		      document.removeEventListener('touchend', endDrag);
		
		      if (gameState.draggedBlock) {
		        const floatingBlock = document.getElementById('floating-block');
		        if (floatingBlock) {
		          floatingBlock.remove();
		        }
		
		        gameState.draggedBlock.originalElement.classList.remove('dragging');
		        
		        // Tenta colocar o bloco na posi√ß√£o de preview salva (Se previewRow/Col for NULL, n√£o houve encaixe v√°lido)
		        if (gameState.previewRow !== null && gameState.previewCol !== null) {
		          placeBlock(gameState.previewRow, gameState.previewCol, gameState.draggedBlock.block);
		        }
		
		        // Limpa o estado de drag
		        gameState.draggedBlock = null;
		        gameState.previewRow = null;
		        gameState.previewCol = null;
		        clearPreview();
		        
		        // A cor do bloco que ser√° usado na anima√ß√£o de limpeza √© guardada em currentBlockData
		        // e √© limpa depois do checkAndClearLines (dentro de placeBlock)
		      }
		      
		      currentBlockElement = null;
		      currentBlockIndex = -1;
		    }
		
	function placeBlock(startRow, startCol, blockData) {
		      if (!gameState.gameActive) return;
		      
		      currentBlockData = blockData; // Salva o bloco colocado para uso em checkAndClearLines
		
		      const shape = blockData.shape;
		      const shapeRows = shape.length;
		      const shapeCols = shape[0].length;
		
		      // 1. Verifica√ß√£o final de validade (novamente, por seguran√ßa)
		      if (startRow + shapeRows > BOARD_SIZE || startCol + shapeCols > BOARD_SIZE) return;
		
		      let canPlace = true;
		      for (let r = 0; r < shapeRows; r++) {
		        for (let c = 0; c < shapeCols; c++) {
		          if (shape[r][c] === 1) {
		            if (gameState.board[startRow + r][startCol + c] !== 0) {
		              canPlace = false;
		              break;
		            }
		          }
		        }
		        if (!canPlace) break;
		      }
		
		      if (!canPlace) return; // N√£o pode colocar
		
		      // 2. Colocar o bloco no tabuleiro
		      playSound('audioPop'); // Som de coloca√ß√£o
		      let cellsFilled = 0;
		      for (let r = 0; r < shapeRows; r++) {
		        for (let c = 0; c < shapeCols; c++) {
		          if (shape[r][c] === 1) {
		            gameState.board[startRow + r][startCol + c] = blockData.color;
		            cellsFilled++;
		          }
		        }
		      }
		
		      // 3. Atualizar pontua√ß√£o pela coloca√ß√£o
		      gameState.score += cellsFilled * 1;
		      
		      // 4. Remover o bloco da lista de blocos dispon√≠veis
		      gameState.blocks.splice(currentBlockIndex, 1);
		
		      // 5. Verificar e limpar linhas/colunas
		      // Retorna o n√∫mero de linhas limpas.
		      const clearedLines = checkAndClearLines(); 
		
		      // 6. Atualizar a exibi√ß√£o (Apenas se nenhuma linha foi limpa. Se limpou, a atualiza√ß√£o ocorre no setTimeout)
		      if (clearedLines === 0) {
		        // NOVO: Se o n√∫mero de blocos for menor que 3, gerar o(s) novo(s) bloco(s)
		        if (gameState.blocks.length < NUM_STARTING_BLOCKS) { 
		            // Gera apenas o(s) bloco(s) necess√°rio(s) para atingir NUM_STARTING_BLOCKS (3)
		            gameState.blocks = gameState.blocks.concat(generateBlocks(NUM_STARTING_BLOCKS - gameState.blocks.length)); 
		        }
		        
		        renderBoard();
		        renderBlocks();
		        updateDisplay();
		        
		        // 7. Checar Game Over
		        if (!canPlaceAnyBlock()) {
		          endGame();
		        }
		      }
		      
		      currentBlockData = null;
		    }
		
	function checkAndClearLines() {
		      let linesToClear = [];
		      // Usar a cor do bloco que acabou de ser colocado (currentBlockData)
		      const clearingColor = currentBlockData ? currentBlockData.color : '#FFFFFF'; // Cor do bloco que completou a linha 
		
		      // Verificar linhas
		      for (let row = 0; row < BOARD_SIZE; row++) {
		        if (gameState.board[row].every(cell => cell !== 0)) {
		          linesToClear.push({ type: 'row', index: row });
		        }
		      }
		
		      // Verificar colunas
		      for (let col = 0; col < BOARD_SIZE; col++) {
		        if (gameState.board.every(row => row[col] !== 0)) {
		          // Adicionado para evitar duplicidade de contagem (se uma linha j√° for contada, a coluna que a intercepta tamb√©m ser√°)
		          linesToClear.push({ type: 'col', index: col });
		        }
		      }
		
		      if (linesToClear.length > 0) {
		        // Atualizar pontua√ß√£o
		        gameState.score += linesToClear.length * 100;
		        showFeedback(linesToClear.length);
		        
		        // Aplicar efeito visual de limpeza
		        linesToClear.forEach(line => {
		          if (line.type === 'row') {
		            for (let col = 0; col < BOARD_SIZE; col++) {
		              const cell = document.getElementById(`cell-${line.index}-${col}`);
		              if (cell && gameState.board[line.index][col] !== 0) { 
		                cell.style.background = clearingColor;
		                cell.style.setProperty('--clearing-color', clearingColor);
		                cell.classList.add('clearing');
		              }
		            }
		          } else { // col
		            for (let row = 0; row < BOARD_SIZE; row++) {
		              const cell = document.getElementById(`cell-${row}-${line.index}`);
		              if (cell && gameState.board[row][line.index] !== 0) {
		                cell.style.background = clearingColor;
		                cell.style.setProperty('--clearing-color', clearingColor);
		                cell.classList.add('clearing');
		              }
		            }
		          }
		        });
		        
		        // Atrasar a limpeza real do tabuleiro e a renderiza√ß√£o para permitir que a anima√ß√£o rode
		        setTimeout(() => {
		          // Limpar o tabuleiro
		          linesToClear.forEach(line => {
		            if (line.type === 'row') {
		              gameState.board[line.index] = Array(BOARD_SIZE).fill(0);
		            } else { // col
		              for (let row = 0; row < BOARD_SIZE; row++) {
		                gameState.board[row][line.index] = 0;
		              }
		            }
		          });
		          
		          // Remover a classe 'clearing' e renderizar o tabuleiro limpo
		          const allCells = document.querySelectorAll('.cell');
		          allCells.forEach(cell => {
		            cell.classList.remove('clearing');
		            cell.style.removeProperty('background');
		            cell.style.removeProperty('--clearing-color');
		          });
		          
		          // NOVO: Gerar blocos e renderizar AP√ìS a anima√ß√£o de limpeza
		          if (gameState.blocks.length < NUM_STARTING_BLOCKS) { 
		            gameState.blocks = gameState.blocks.concat(generateBlocks(NUM_STARTING_BLOCKS - gameState.blocks.length)); 
		          }
		          
		          renderBoard();
		          renderBlocks(); 
		          updateDisplay();
		          
		          // Verifica game over novamente ap√≥s a limpeza
		          if (!canPlaceAnyBlock()) {
		            endGame();
		          }
		          
		        }, 550); // O delay DEVE ser maior que a dura√ß√£o da anima√ß√£o (0.5s)
		        
		        return linesToClear.length; // Retorna o n√∫mero de linhas limpas
		        
		      } else {
		        return 0; // N√£o houve limpeza
		      }
		    }
	
	    function canPlace(startRow, startCol, shape) {
	      const shapeRows = shape.length;
	      const shapeCols = shape[0].length;
	
	      // 1. Verificar limites
	      if (startRow + shapeRows > BOARD_SIZE || startCol + shapeCols > BOARD_SIZE || startRow < 0 || startCol < 0) {
	        return false;
	      }
	
	      // 2. Verificar sobreposi√ß√£o
	      for (let r = 0; r < shapeRows; r++) {
	        for (let c = 0; c < shapeCols; c++) {
	          if (shape[r][c] === 1) {
	            if (gameState.board[startRow + r][startCol + c] !== 0) {
	              return false; // C√©lula j√° ocupada
	            }
	          }
	        }
	      }
	
	      return true;
	    }
	
	    function canPlaceAnyBlock() {
	      for (const block of gameState.blocks) {
	        const shape = block.shape;
	        const shapeRows = shape.length;
	        const shapeCols = shape[0].length;
	
	        // Percorre todas as posi√ß√µes poss√≠veis no tabuleiro
	        for (let r = 0; r <= BOARD_SIZE - shapeRows; r++) {
	          for (let c = 0; c <= BOARD_SIZE - shapeCols; c++) {
	            if (canPlace(r, c, shape)) {
	              return true; // Encontrou pelo menos um local para este bloco
	            }
	          }
	        }
	      }
	      return false; // N√£o h√° blocos restantes que possam ser colocados
	    }
	
	    function renderBlocks() {
	      const blocksGridElement = document.getElementById('blocksGrid');
	      blocksGridElement.innerHTML = '';
	
	      gameState.blocks.forEach((block, index) => {
	        const blockDiv = document.createElement('div');
	        blockDiv.className = 'draggable-block';
	        blockDiv.id = `block-${block.id}`;
	        blockDiv.dataset.index = index;
	        blockDiv.dataset.color = block.color;
	
	        const grid = document.createElement('div');
	        grid.className = 'block-grid';
	
	        // Ajustar grid-template-columns com base na largura da forma
	        const cols = block.shape[0].length;
	        grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
	
	        block.shape.forEach(row => {
	          row.forEach(cell => {
	            const cellDiv = document.createElement('div');
	            cellDiv.className = 'block-cell';
	            if (cell === 1) {
	              cellDiv.style.background = block.color;
	            } else {
	              cellDiv.style.background = 'transparent';
	              cellDiv.style.border = 'none';
	            }
	            grid.appendChild(cellDiv);
	          });
	        });
	
	        blockDiv.appendChild(grid);
	
	        // Configurar eventos de arrastar
	        blockDiv.addEventListener('mousedown', startDrag);
	        blockDiv.addEventListener('touchstart', startDrag, { passive: false });
	        
	        blocksGridElement.appendChild(blockDiv);
	      });
	    }
	
	    function updateDisplay() {
	      document.getElementById('scoreDisplay').textContent = gameState.score;
	      // document.getElementById('levelDisplay').textContent = `N√≠vel ${gameState.level}`; // Removido
	    }
	
	    function endGame() {
	      gameState.gameActive = false;
	      document.getElementById('finalScore').textContent = gameState.score;
	      document.getElementById('gameOverModal').classList.remove('hidden');
	      toggleBackgroundMusic(false);
	    }
	    
	    // Fun√ß√£o para mostrar o feedback de pontua√ß√£o e combo
	    function showFeedback(clearedLines) {
	      let comboText = '';
	      let comboColor = '#FFD700'; // Cor padr√£o
	      let soundId = 'audioWow';
	      
	      if (clearedLines === 1) {
	        comboText = "Bom!";
	        comboColor = "#00CED1";
	        soundId = 'audioWow';
	      } else if (clearedLines === 2) {
	        comboText = "√ìtimo!";
	        comboColor = "#FF6347";
	        soundId = 'audioAmazing';
	      } else if (clearedLines >= 3) {
	        comboText = "FANT√ÅSTICO!";
	        comboColor = "#FFD700";
	        soundId = 'audioFantastic';
	      }
	      
	      if (comboText) {
	        playSound(soundId);
	        
	        const comboElement = document.createElement('div');
	        comboElement.className = 'combo-animation';
	        comboElement.textContent = `+${clearedLines * 100} Pts! (${comboText})`;
	        comboElement.style.setProperty('--combo-color', comboColor);
	        
	        // Calcular posi√ß√£o central da tela
	        const x = window.innerWidth / 2;
	        const y = window.innerHeight / 2;
	        comboElement.style.left = `${x}px`;
	        comboElement.style.top = `${y}px`;
	        comboElement.style.transform = `translate(-50%, -50%)`;
	        
	        document.body.appendChild(comboElement);
	        
	        setTimeout(() => {
	          comboElement.remove();
	        }, 1000);
	      }
	    }
	
	    // --- Fun√ß√µes de Configura√ß√µes ---
	    function openSettings() {
	      playSound('audioPop');
	      document.getElementById('settingsModal').classList.remove('hidden');
	      updateProgressBar(); // Garante que o player est√° com o estado correto
	    }
	
	    function closeSettings() {
	      playSound('audioPop');
	      document.getElementById('settingsModal').classList.add('hidden');
	    }
	
	    function toggleSound() {
	      gameState.soundEnabled = !gameState.soundEnabled;
	      const toggle = document.getElementById('soundToggle');
	      if (gameState.soundEnabled) {
	        toggle.classList.add('active');
	        playSound('audioPop');
	        toggleBackgroundMusic(true);
	      } else {
	        toggle.classList.remove('active');
	        toggleBackgroundMusic(false);
	        const audio = getCurrentAudio();
	        if (audio) audio.pause();
	      }
	      updateProgressBar(); // For√ßa a atualiza√ß√£o do player para refletir o estado
	    }
	
	    function toggleDarkMode() {
	      playSound('audioPop');
	      gameState.darkMode = !gameState.darkMode;
	      const toggle = document.getElementById('darkModeToggle');
	      if (gameState.darkMode) {
	        document.body.classList.add('dark-mode');
	        toggle.classList.add('active');
	      } else {
	        document.body.classList.remove('dark-mode');
	        toggle.classList.remove('active');
	      }
	    }
	
	    // Inicializar toggles
	    function initToggles() {
	      const soundToggle = document.getElementById('soundToggle');
	      const darkModeToggle = document.getElementById('darkModeToggle');
	      
	      if (gameState.soundEnabled) {
	        soundToggle.classList.add('active');
	      }
	      if (gameState.darkMode) {
	        darkModeToggle.classList.add('active');
	      }
	    }
	
		    // Bot√£o voltar para o site
		    const backToSiteBtn = document.getElementById('backToSiteBtn');
		    if (backToSiteBtn) {
		      backToSiteBtn.addEventListener('click', () => {
		        playSound('audioPop'); // Adicionado som de pop
		        window.close();
		        setTimeout(() => {
		          window.location.href = '/index.html';
		        }, 100);
		      });
		    }
	
		    // Inicializa√ß√£o da m√∫sica (garantir que o evento 'ended' esteja configurado)
		    document.addEventListener('DOMContentLoaded', () => {
		        for (let i = 0; i < MUSIC_LIST.length; i++) {
		            const audio = document.getElementById(`audioBackground${i + 1}`);
		            if (audio) {
		                // Garante que o loop de pr√≥xima m√∫sica esteja configurado
		                audio.onended = playNextMusic;
		                // Configura o ouvinte para o progresso do tempo
		                audio.addEventListener('timeupdate', updateProgressBar);
		            }
		        }
		    });
	  </script>
	</body>
</html>
