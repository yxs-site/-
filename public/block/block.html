<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Block Blast - Tutyxs 3.0</title>
  <style>
    * {
      margin: 0;
      padding: 0;
	      box-sizing: border-box;
	      -webkit-user-select: none; /* Safari */
	      -moz-user-select: none; /* Firefox */
	      -ms-user-select: none; /* IE10+ */
	      user-select: none; /* Standard */
	    }

body {
	      /* O fundo.gif agora √© aplicado ao pseudo-elemento ::before para permitir o filtro de brilho isolado */
      color: white;
      font-family: 'Arial', sans-serif;
      text-align: center;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center; /* Revertido para centralizar verticalmente */
		      padding: 15px;
	      overflow: hidden; /* Revertido para ocultar rolagem, como estava originalmente */
	    }
	
	    body::before {
	      content: '';
	      position: fixed;
	      top: 0;
	      left: 0;
	      width: 100%;
	      height: 100%;
	      background: url('fundo.gif') no-repeat center center fixed;
	      background-size: cover;
	      z-index: -1; /* Coloca o fundo atr√°s do conte√∫do */
	      transition: filter 0.5s ease; /* Transi√ß√£o suave para o filtro */
	    }

    #backToSiteBtn {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.3);
      color: white;
      border: 2px solid white;
      padding: 10px;
      border-radius: 50%;
      cursor: pointer;
	      font-size: 1.2rem;
      font-weight: bold;
      z-index: 1000;
      transition: all 0.3s ease-in-out;
      display: flex;
      align-items: center;
      justify-content: center;
	      width: 40px;
	      height: 40px;
      text-decoration: none;
    }

    #backToSiteBtn:hover {
      background: rgba(255, 255, 255, 0.5);
      transform: scale(1.1);
    }

    #backToSiteBtn:active {
      width: auto;
      border-radius: 10px;
	      padding: 5px 10px;
    }

    #backToSiteBtn .arrow {
      margin-right: 0;
      transition: margin-right 0.3s;
    }

    #backToSiteBtn:active .arrow {
	      margin-right: 5px;
    }

    #backToSiteBtn .text {
      display: none;
      white-space: nowrap;
    }

    #backToSiteBtn:active .text {
      display: inline;
    }

.container {
	      max-width: 350px;
	      width: 100%;
	      background: transparent; /* Padr√£o sem fundo */
	      padding: 20px;
	      border-radius: 30px;
	      box-shadow: none;
	    }

	    .header {
	      display: flex;
	      justify-content: space-between;
	      align-items: center;
	      margin-bottom: 10px;
	      gap: 20px;
	    }

    .score-display {
      font-size: 2rem;
      font-weight: bold;
      color: #FFD700;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .score-display::before {
      content: "üëë";
      font-size: 2rem;
    }

    .level-display {
      font-size: 1.5rem;
      font-weight: bold;
      background: rgba(0, 0, 0, 0.3);
      padding: 15px 25px;
      border-radius: 15px;
      border: 3px solid rgba(255, 255, 255, 0.3);
    }

    .settings-btn {
      font-size: 1.5rem;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.3);
      padding: 10px 15px;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      color: white;
    }

    .settings-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(1.1);
    }

.game-board {
	      background: #1a2a5a; /* Removendo o blur */
	      border: 4px solid rgba(255, 255, 255, 0.3);
	      border-radius: 15px;
	      padding: 10px;
	      margin-bottom: 10px;
	      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 0, 0, 0.3);
	      display: grid;
	      grid-template-columns: repeat(6, 1fr);
	      gap: 8px;
	    }

    .cell {
      aspect-ratio: 1;
      background: rgba(0, 0, 0, 0.3);
      border: 3px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      user-select: none;
    }

    .cell:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.4);
    }

    .cell.filled {
      border-color: rgba(255, 255, 255, 0.5);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 0 10px rgba(0, 0, 0, 0.2);
    }

    .cell.preview {
      border: 3px solid rgba(200, 200, 200, 0.6) !important;
      background: rgba(100, 100, 100, 0.6) !important;
      box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
    }

.blocks-container {
	      background: rgba(255, 255, 255, 0.2); /* 20% de opacidade */
	      backdrop-filter: blur(10px); /* Mantendo o blur aqui */
	      border: 3px solid rgba(255, 255, 255, 0.3);
	      border-radius: 15px;
	      padding: 20px;
	      margin-bottom: 10px;
	    }

    .blocks-label {
      font-size: 0.9rem;
      opacity: 0.8;
	      margin-bottom: 5px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

	    .blocks-grid {
	      display: flex;
	      justify-content: center;
	      gap: 15px;
	      flex-wrap: wrap;
	      align-items: center; /* Adicionado para alinhar verticalmente */
	    }

	    .draggable-block {
	      cursor: grab;
	      user-select: none;
	      transition: all 0.2s;
	      padding: 5px;
	      background: transparent; /* Removido o fundo */
	      border-radius: 10px;
	      border: 2px solid transparent; /* Removido a borda */
	    }

	    .draggable-block:hover {
	      transform: scale(1.05);
	      background: transparent; /* Removido o fundo */
	    }

    .draggable-block:active {
      cursor: grabbing;
    }

    .draggable-block.dragging {
      opacity: 0;
    }

    .block-grid {
      display: grid;
      gap: 4px;
      grid-template-columns: repeat(auto-fit, minmax(30px, 1fr));
    }

	    .block-cell {
	      width: 30px;
	      height: 30px;
	      border-radius: 5px;
	      border: 2px solid rgba(0, 0, 0, 0.3);
	    }

    .controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 20px;
    }

    button {
      padding: 12px 20px;
      border: none;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      cursor: pointer;
      font-size: 1rem;
      font-weight: bold;
      transition: all 0.3s;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    button:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

		    .info-text {
		      font-size: 0.8rem;
	      background: linear-gradient(to right, #4169E1, #4B0082);
	      -webkit-background-clip: text;
	      -webkit-text-fill-color: transparent;
	      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	      font-weight: bold;
	      margin-top: 10px;
	    }

    .menu-screen {
      display: block;
    }

    .menu-screen.hidden {
      display: none;
    }

    .game-screen {
      display: none;
    }

.game-screen.show {
	      display: block;
	    }
	
	    /* Estilos espec√≠ficos para o menu */
	    #menuScreen.container {
	      background: rgba(255, 255, 255, 0.2); /* 20% de opacidade */
	      backdrop-filter: blur(10px);
	      border: 2px solid white;
	    }

    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }

    .modal.hidden {
      display: none !important;
    }

    .settings-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }

    .settings-modal.hidden {
      display: none !important;
    }

    .settings-content {
      background: transparent;
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      max-width: 400px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
    }

    .settings-content h2 {
      font-size: 2rem;
      margin-bottom: 30px;
      color: #FFD700;
    }

    .setting-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    .setting-item label {
      font-size: 1.1rem;
      font-weight: bold;
      color: white;
    }

    .toggle-switch {
      position: relative;
      width: 60px;
      height: 30px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      cursor: pointer;
      border: 2px solid rgba(255, 255, 255, 0.3);
      transition: all 0.3s;
    }

    .toggle-switch.active {
      background: #00FF00;
    }

    .toggle-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 24px;
      height: 24px;
      background: white;
      border-radius: 50%;
      transition: left 0.3s;
    }

    .toggle-switch.active .toggle-slider {
      left: 32px;
    }

    .settings-content button {
      width: 100%;
      margin-top: 20px;
      padding: 15px;
      font-size: 1.1rem;
    }

body.dark-mode::before {
			      filter: brightness(50%); /* Diminui o brilho em 50% */
			    }

body.dark-mode .container {
	      background: transparent; /* Padr√£o sem fundo */
	    }

    body.dark-mode .game-board {
      background: #0a1428;
      border-color: rgba(255, 255, 255, 0.2);
    }

    body.dark-mode .cell {
      background: rgba(0, 0, 0, 0.5);
      border-color: rgba(255, 255, 255, 0.1);
    }

    body.dark-mode .cell:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .modal-content {
      background: transparent;
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      max-width: 400px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
    }

    .modal-content h2 {
      font-size: 2.5rem;
      margin-bottom: 20px;
      color: #FFD700;
    }

    .modal-content p {
      font-size: 1.3rem;
      margin-bottom: 20px;
      color: #00ff00;
    }

    .modal-content button {
      width: 100%;
      margin: 10px 0;
      padding: 15px;
      font-size: 1.1rem;
    }

h1 {
	      font-size: 2rem; /* Reduzindo o tamanho da fonte */
	      margin-bottom: 15px; /* Reduzindo a margem */
	      text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
	      white-space: nowrap; /* Tentando manter na mesma linha */
	    }

    .menu-screen button {
      width: 100%;
      padding: 20px;
      font-size: 1.3rem;
      margin-top: 20px;
    }

    .relaxing-text {
      font-size: 1.5rem;
      color: #00ff00;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      margin-top: 20px;
    }

    .combo-animation {
      position: fixed;
      font-size: 2rem;
      font-weight: bold;
      color: #FFD700;
      pointer-events: none;
      animation: floatUp 1s ease-out forwards;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    @keyframes floatUp {
      0% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateY(-80px) scale(0.5);
      }
    }
  </style>
</head>
<body>
  <button id="backToSiteBtn">
    <span class="arrow">‚Üê</span>
    <span class="text">Voltar</span>
  </button>

  <!-- Menu Principal -->
  <div id="menuScreen" class="container menu-screen">
    <h1 style="display: flex; align-items: center; justify-content: center; gap: 10px;">üéÆ BLOCK BLAST</h1>
    <p style="font-size: 1.2rem; margin-bottom: 30px; opacity: 0.9;">Arraste os blocos e complete as linhas!</p>
    <button onclick="startGame()" style="width: 100%; padding: 20px; font-size: 1.3rem;">Come√ßar Jogo</button>
  </div>

  <!-- Tela do Jogo -->
  <div id="gameScreen" class="container game-screen">
    <div class="header">
      <div class="score-display" id="scoreDisplay">0</div>
      <button class="settings-btn" onclick="openSettings()">‚öôÔ∏è</button>
    </div>

    <div class="game-board" id="gameBoard"></div>

    <div class="blocks-container">
      <div class="blocks-label">Pr√≥ximos Blocos</div>
      <div class="blocks-grid" id="blocksGrid"></div>
    </div>

	    <div class="controls">
	      <button onclick="resetGame()">üîÑ Reiniciar Jogo</button>
	    </div>

	    <div class="info-text" id="infoText">YXS</div>
  </div>

  <!-- Modal de Configura√ß√µes -->
  <div id="settingsModal" class="settings-modal hidden" onclick="closeSettings()">
    <div class="settings-content" onclick="event.stopPropagation()">
      <h2>‚öôÔ∏è Configura√ß√µes</h2>
      
      <div class="setting-item">
        <label>Som</label>
        <div class="toggle-switch" id="soundToggle" onclick="toggleSound()">
          <div class="toggle-slider"></div>
        </div>
      </div>

      <div class="setting-item">
        <label>Modo Escuro</label>
        <div class="toggle-switch" id="darkModeToggle" onclick="toggleDarkMode()">
          <div class="toggle-slider"></div>
        </div>
      </div>

      <button onclick="closeSettings()">Fechar</button>
      <button onclick="goToMenu()" style="background: #FF6B6B;">Sair do Jogo</button>
    </div>
  </div>

  <!-- Modal de Game Over -->
  <div id="gameOverModal" class="modal hidden">
    <div class="modal-content">
      <h2>Game Over!</h2>
      <p>Pontua√ß√£o Final: <span id="finalScore" style="color: #FFD700;">0</span></p>
      <button onclick="resetGame()">Jogar Novamente</button>
      <button onclick="goToMenu()">Menu Principal</button>
    </div>
  </div>

  <!-- Audio Elements -->
  <audio id="audioWow" src="wow.mp3" preload="auto"></audio>
  <audio id="audioAmazing" src="amazing.mp3" preload="auto"></audio>
  <audio id="audioFantastic" src="fantastic.mp3" preload="auto"></audio>
	  <audio id="audioBackground1" src="musica1.mp3" preload="auto"></audio>
	  <audio id="audioBackground2" src="musica2.mp3" preload="auto"></audio>
	  <audio id="audioBackground3" src="musica3.mp3" preload="auto"></audio>
  <audio id="audioPop" src="pop.mp3" preload="auto"></audio>

  <script>
    function playSound(audioId) {
      if (audioId === 'audioPop') {
        // Para o pop, usamos um volume mais baixo para n√£o competir com a m√∫sica de fundo
        // e n√£o clonamos, pois ele √© um som r√°pido e pode ser reproduzido v√°rias vezes.
        // Se o usu√°rio quiser o pop em todos os cliques, ele deve ser r√°pido.
        const audio = document.getElementById(audioId);
        if (audio && gameState.soundEnabled) {
          audio.currentTime = 0;
          audio.volume = 0.3;
          audio.play().catch(e => console.error("Erro ao reproduzir √°udio:", e));
        }
        return;
      }


      if (gameState.soundEnabled) {
        const audio = document.getElementById(audioId);
        if (audio) {
          // Clonar o n√≥ de √°udio para permitir que o som seja reproduzido
          // v√°rias vezes rapidamente sem atraso (solu√ß√£o para o atraso do WOW)
          const clone = audio.cloneNode();
          clone.volume = 0.5; // Ajustar volume para evitar estouro
          clone.play().catch(e => console.error("Erro ao reproduzir √°udio:", e));
        }
      }
    }

	    let currentMusicIndex = 1;
	    const MAX_MUSIC_INDEX = 3; // Considerando musica1, musica2, e musica3
	
	    function getAudioElement(index) {
	      return document.getElementById(`audioBackground${index}`);
	    }
	
	    function playNextMusic() {
	      const currentAudio = getAudioElement(currentMusicIndex);
	      if (currentAudio) {
	        currentAudio.pause();
	        currentAudio.currentTime = 0;
	      }
	
	      currentMusicIndex++;
	      if (currentMusicIndex > MAX_MUSIC_INDEX || !getAudioElement(currentMusicIndex)) {
	        currentMusicIndex = 1; // Volta para a primeira se a pr√≥xima n√£o existir ou for al√©m do m√°ximo
	      }
	
	      const nextAudio = getAudioElement(currentMusicIndex);
	      if (nextAudio && gameState.soundEnabled) {
	        nextAudio.volume = 0.6;
	        nextAudio.play().catch(e => console.error("Erro ao reproduzir m√∫sica de fundo:", e));
	        nextAudio.onended = playNextMusic; // Configura o loop para a pr√≥xima m√∫sica
	      }
	    }
	
	    function toggleBackgroundMusic(play) {
	      const audio1 = getAudioElement(1);
	      if (!audio1) return;
	
	      if (play && gameState.soundEnabled) {
	        // Se for a primeira vez que toca, come√ßa a partir da musica1
	        if (currentMusicIndex === 1 && audio1.paused) {
	          audio1.volume = 0.6;
	          audio1.play().catch(e => console.error("Erro ao reproduzir m√∫sica de fundo:", e));
	          audio1.onended = playNextMusic;
	        } else if (getAudioElement(currentMusicIndex).paused) {
	          // Se j√° estava tocando e foi pausada, retoma a atual
	          getAudioElement(currentMusicIndex).play().catch(e => console.error("Erro ao reproduzir m√∫sica de fundo:", e));
	        }
	      } else {
	        // Pausa todas as m√∫sicas
	        for (let i = 1; i <= MAX_MUSIC_INDEX; i++) {
	          const audio = getAudioElement(i);
	          if (audio) {
	            audio.pause();
	          }
	        }
	      }
	    }


    const BOARD_SIZE = 6;
    const COLORS = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
      '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B88B', '#A8E6CF',
      '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF'
    ];

    const BLOCK_SHAPES = [
      { shape: [[1]], name: '1x1' },
      { shape: [[1, 1]], name: '1x2' },
      { shape: [[1], [1]], name: '2x1' },
      { shape: [[1, 1], [1, 1]], name: '2x2' },
      { shape: [[1, 1, 1]], name: '1x3' },
      { shape: [[1], [1], [1]], name: '3x1' },
      { shape: [[1, 0], [1, 1]], name: 'L' },
      { shape: [[0, 1], [1, 1]], name: 'L2' },
      { shape: [[1, 1, 1, 1]], name: '1x4' }
    ];

    let gameState = {
      board: [],
      score: 0,
	      level: 0,
      blocks: [],
      gameActive: false,
      draggedBlock: null,
      previewRow: null,
      previewCol: null,
      darkMode: false,
      soundEnabled: true
    };

    function initGame() {
      gameState.board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(0));
      gameState.score = 0;
	      // gameState.level = 480; // Removido por solicita√ß√£o do usu√°rio
      gameState.gameActive = true;
      gameState.blocks = generateBlocks(3);
      gameState.draggedBlock = null;

      renderBoard();
      renderBlocks();
      updateDisplay();
    }

    function startGame() {
      playSound('audioPop');
      document.getElementById('menuScreen').classList.add('hidden');
      document.getElementById('gameScreen').classList.add('show');
      document.getElementById('gameOverModal').classList.add('hidden');
      document.getElementById('settingsModal').classList.add('hidden');
      initToggles();
      initGame();
      toggleBackgroundMusic(true);
    }

    function goToMenu() {
      playSound('audioPop');
      document.getElementById('menuScreen').classList.remove('hidden');
      document.getElementById('gameScreen').classList.remove('show');
      document.getElementById('gameOverModal').classList.add('hidden');
      document.getElementById('settingsModal').classList.add('hidden');
      gameState.gameActive = false;
      toggleBackgroundMusic(false);
    }

    function resetGame() {
      playSound('audioPop');
      startGame();
    }

    function generateBlocks(count) {
      const blocks = [];
      for (let i = 0; i < count; i++) {
        const shapeObj = BLOCK_SHAPES[Math.floor(Math.random() * BLOCK_SHAPES.length)];
        const color = COLORS[Math.floor(Math.random() * COLORS.length)];
        blocks.push({
          id: Math.random(),
          shape: shapeObj.shape,
          color: color,
          name: shapeObj.name
        });
      }
      return blocks;
    }

    function renderBoard() {
      const boardElement = document.getElementById('gameBoard');
      boardElement.innerHTML = '';

      for (let row = 0; row < BOARD_SIZE; row++) {
        for (let col = 0; col < BOARD_SIZE; col++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.id = `cell-${row}-${col}`;
          cell.dataset.row = row;
          cell.dataset.col = col;

          if (gameState.board[row][col] !== 0) {
            cell.classList.add('filled');
            cell.style.background = gameState.board[row][col];
          }

	          // Removendo listeners de drag-and-drop nativos
	          cell.addEventListener('mouseover', (e) => {
	            if (gameState.draggedBlock) {
	              const row = parseInt(cell.dataset.row);
	              const col = parseInt(cell.dataset.col);
	              showPreview(row, col);
	            }
	          });

          boardElement.appendChild(cell);
        }
      }
    }

	    function showPreview(hoverRow, hoverCol) {
	      // Limpar preview anterior
	      const allCells = document.querySelectorAll('.cell');
	      allCells.forEach(cell => {
	        if (cell.classList.contains('preview')) {
	          cell.classList.remove('preview');
	          cell.style.background = '';
	          cell.style.borderColor = '';
	        }
	      });
	      
	      if (!gameState.draggedBlock) return;
	
	      const block = gameState.draggedBlock.block;
	      const shape = block.shape;
	      const shapeRows = shape.length;
	      const shapeCols = shape[0].length;
	
		      // L√≥gica de coloca√ß√£o mais tolerante: tenta centralizar o bloco na c√©lula sob o mouse
		      const centerRow = Math.floor(shapeRows / 2);
		      const centerCol = Math.floor(shapeCols / 2);
		
		      let startRow = hoverRow - centerRow;
		      let startCol = hoverCol - centerCol;
		
		      // Ajustar para que o bloco n√£o saia do tabuleiro
		      if (startRow < 0) startRow = 0;
		      if (startCol < 0) startCol = 0;
		      if (startRow + shapeRows > BOARD_SIZE) startRow = BOARD_SIZE - shapeRows;
		      if (startCol + shapeCols > BOARD_SIZE) startCol = BOARD_SIZE - shapeCols;
	
	      // Verificar se cabe
	      if (startRow + shapeRows > BOARD_SIZE || startCol + shapeCols > BOARD_SIZE) {
	        return;
	      }
	
	      // Verificar se as c√©lulas est√£o vazias
	      let canPlace = true;
	      for (let r = 0; r < shapeRows; r++) {
	        for (let c = 0; c < shapeCols; c++) {
	          if (shape[r][c] === 1) {
	            if (gameState.board[startRow + r][startCol + c] !== 0) {
	              canPlace = false;
	              break;
	            }
	          }
	        }
	        if (!canPlace) break;
	      }
	
	      if (!canPlace) return;
	
	      // Mostrar preview apenas das c√©lulas que t√™m bloco (shape[r][c] === 1)
	      for (let r = 0; r < shapeRows; r++) {
	        for (let c = 0; c < shapeCols; c++) {
	          if (shape[r][c] === 1) {
	            const cellId = `cell-${startRow + r}-${startCol + c}`;
	            const cell = document.getElementById(cellId);
	            if (cell) {
	              cell.classList.add('preview');
	              cell.style.background = 'rgba(100, 100, 100, 0.6)';
	              cell.style.borderColor = 'rgba(200, 200, 200, 0.6)';
	            }
	          }
	        }
	      }
	      
	      // Salvar a posi√ß√£o de in√≠cio calculada para uso no drop
	      gameState.previewRow = startRow;
	      gameState.previewCol = startCol;
	    }

	    function clearPreview() {
	      const allCells = document.querySelectorAll('.cell');
	      allCells.forEach(cell => {
	        if (cell.classList.contains('preview')) {
	          cell.classList.remove('preview');
	          cell.style.background = '';
	          cell.style.borderColor = '';
	        }
	      });
	    }
	
	    // --- Fun√ß√µes de Drag Customizado ---
	
	    function getEventCoords(e) {
	      if (e.touches) {
	        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
	      }
	      return { x: e.clientX, y: e.clientY };
	    }
	
	    function getCellUnderCoords(x, y) {
	      const element = document.elementFromPoint(x, y);
	      if (element && element.classList.contains('cell')) {
	        return element;
	      }
	      return null;
	    }
	
	    function startDrag(e) {
	      e.preventDefault();
	      if (e.button === 2) return; // Ignora clique com o bot√£o direito
	
	      const blockDiv = e.currentTarget;
	      const blockId = blockDiv.id.split('-')[1];
	      const blockIndex = gameState.blocks.findIndex(b => b.id == blockId);
	
	      if (blockIndex === -1) return;
	
	      currentBlockElement = blockDiv;
	      currentBlockIndex = blockIndex;
	      currentBlockData = gameState.blocks[blockIndex];
	      gameState.draggedBlock = { block: currentBlockData, index: currentBlockIndex };
	
	      // Cria um clone flutuante para o arrasto
	      const clone = blockDiv.cloneNode(true);
	      clone.id = 'floating-block';
	      clone.style.position = 'fixed';
	      clone.style.zIndex = 1000;
	      clone.style.pointerEvents = 'none';
	      clone.style.opacity = 0.8;
	      clone.style.transform = 'scale(1.2)';
	      document.body.appendChild(clone);
	
	      // Oculta o bloco original
	      blockDiv.style.opacity = 0;
	
	      const coords = getEventCoords(e);
	      moveFloatingBlock(coords.x, coords.y);
	
	      document.addEventListener('mousemove', drag);
	      document.addEventListener('mouseup', stopDrag);
	      document.addEventListener('touchmove', drag);
	      document.addEventListener('touchend', stopDrag);
	    }
	
	    function moveFloatingBlock(x, y) {
	      const floatingBlock = document.getElementById('floating-block');
	      if (floatingBlock) {
        // Ajusta a posi√ß√£o para centralizar o bloco no cursor, usando style.left e style.top para tentar resolver o problema de posicionamento em dispositivos m√≥veis.
        const rect = floatingBlock.getBoundingClientRect();
        floatingBlock.style.left = `${x - rect.width / 2}px`;
        floatingBlock.style.top = `${y - rect.height / 2}px`;
        floatingBlock.style.transform = `scale(1.2)`; // Mant√©m o scale para o efeito visual
	      }
	    }
	
	    let lastPreviewCell = null;
	    let isDragging = false;
	
		    function drag(e) {
		      if (!gameState.draggedBlock) return;
		      // O preventDefault √© importante para evitar a rolagem da p√°gina em dispositivos touch
		      // e garantir que o evento touchmove seja tratado corretamente.
		      e.preventDefault(); 

	
	      isDragging = true;
	      const coords = getEventCoords(e);
	      moveFloatingBlock(coords.x, coords.y);
	
	      // Otimiza√ß√£o: Apenas recalcula o preview se o bloco flutuante estiver sobre uma c√©lula diferente
	      const cell = getCellUnderCoords(coords.x, coords.y);
	      if (cell && cell !== lastPreviewCell) {
	        lastPreviewCell = cell;
	        const row = parseInt(cell.dataset.row);
	        const col = parseInt(cell.dataset.col);
	        showPreview(row, col);
	      } else if (!cell && lastPreviewCell) {
	        lastPreviewCell = null;
	        clearPreview();
	        gameState.previewRow = null;
	        gameState.previewCol = null;
	      }
	    }
	
	    function stopDrag(e) {
	      // e.preventDefault(); // N√£o previne o default aqui para n√£o interferir com o clique
	      document.removeEventListener('mousemove', drag);
	      document.removeEventListener('mouseup', stopDrag);
	      document.removeEventListener('touchmove', drag);
	      document.removeEventListener('touchend', stopDrag);
	
	      const floatingBlock = document.getElementById('floating-block');
	      if (floatingBlock) {
	        floatingBlock.remove();
	      }
	
	      if (currentBlockElement) {
	        currentBlockElement.style.opacity = 1; // Torna o bloco original vis√≠vel novamente
	      }
	
	      // Tenta colocar o bloco na √∫ltima posi√ß√£o de preview v√°lida
	      if (gameState.draggedBlock && gameState.previewRow !== null && gameState.previewCol !== null) {
	        placeBlock(gameState.previewRow, gameState.previewCol);
	      }
	
	      // Limpa o estado de arrasto
	      gameState.draggedBlock = null;
	      gameState.previewRow = null;
	      gameState.previewCol = null;
	      currentBlockElement = null;
	      currentBlockIndex = -1;
	      currentBlockData = null;
	      clearPreview();
	    }

	    // Vari√°veis globais para o drag customizado
	    let currentBlockElement = null;
	    let currentBlockIndex = -1;
	    let currentBlockData = null;
	
	    function renderBlocks() {
	      const blocksGrid = document.getElementById('blocksGrid');
	      blocksGrid.innerHTML = '';
	
	      gameState.blocks.forEach((block, index) => {
        const blockDiv = document.createElement('div');
        blockDiv.className = 'draggable-block';
	        blockDiv.draggable = false; // Desabilita o drag-and-drop nativo
        blockDiv.id = `block-${block.id}`;

        const blockGrid = document.createElement('div');
        blockGrid.className = 'block-grid';
        blockGrid.style.gridTemplateColumns = `repeat(${block.shape[0].length}, 1fr)`;

        for (let row = 0; row < block.shape.length; row++) {
          for (let col = 0; col < block.shape[row].length; col++) {
            const cell = document.createElement('div');
            cell.className = 'block-cell';
	            if (block.shape[row][col]) {
	              cell.style.background = block.color;
	            } else {
	              cell.style.background = 'transparent';
	              cell.style.border = 'none';
	            }
            blockGrid.appendChild(cell);
          }
        }

        blockDiv.appendChild(blockGrid);

	        // Implementa√ß√£o de drag-and-drop customizada (mouse e touch)
	        blockDiv.addEventListener('mousedown', startDrag);
	        blockDiv.addEventListener('touchstart', startDrag);

        blocksGrid.appendChild(blockDiv);
      });
    }

	    function placeBlock(startRow, startCol) {
	      if (!gameState.draggedBlock || !gameState.gameActive) return;
	
	      const block = gameState.draggedBlock.block;
	      const shape = block.shape;
	      const shapeRows = shape.length;
	      const shapeCols = shape[0].length;
	
	      // Verificar se cabe (j√° foi verificado no showPreview, mas √© bom ter aqui)
	      if (startRow < 0 || startCol < 0 || startRow + shapeRows > BOARD_SIZE || startCol + shapeCols > BOARD_SIZE) {
	        return;
	      }
	
	      // Verificar se as c√©lulas est√£o vazias - APENAS onde shape[r][c] === 1
	      for (let r = 0; r < shapeRows; r++) {
	        for (let c = 0; c < shapeCols; c++) {
	          if (shape[r][c] === 1) {
	            const boardRow = startRow + r;
	            const boardCol = startCol + c;
	            if (boardRow < 0 || boardRow >= BOARD_SIZE || boardCol < 0 || boardCol >= BOARD_SIZE) {
	              return;
	            }
	            if (gameState.board[boardRow][boardCol] !== 0) {
	              return;
	            }
	          }
	        }
	      }
	
		      // Colocar o bloco
		      for (let r = 0; r < shapeRows; r++) {
		        for (let c = 0; c < shapeCols; c++) {
		          if (shape[r][c] === 1) {
		            const boardRow = startRow + r;
		            const boardCol = startCol + c;
		            if (boardRow >= 0 && boardRow < BOARD_SIZE && boardCol >= 0 && boardCol < BOARD_SIZE) {
		              gameState.board[boardRow][boardCol] = block.color;
		            }
		          }
		        }
		      }
		      
		      // Tocar som de "pop" ao colocar o bloco
		      playSound('audioPop');
	
	      // Remover bloco da lista
		      gameState.blocks.splice(gameState.draggedBlock.index, 1);
		      // Limpeza de estado √© feita no stopDrag, n√£o aqui.
		      // gameState.draggedBlock = null; // Removido para ser limpo no stopDrag
		      // gameState.previewRow = null; // Removido para ser limpo no stopDrag
		      // gameState.previewCol = null; // Removido para ser limpo no stopDrag
	
	      // Gerar novo bloco
	      if (gameState.blocks.length < 3) {
	        gameState.blocks.push(...generateBlocks(1));
	      }
	
	      // Verificar linhas e colunas
	      checkAndClearLines();
	
	      // Verificar game over
	      if (!canPlaceAnyBlock()) {
	        endGame();
	        return;
	      }
	
	      renderBoard();
	      renderBlocks();
	      updateDisplay();
	    }

    function checkAndClearLines() {
      let clearedLines = 0;

      // Verificar linhas
      for (let row = 0; row < BOARD_SIZE; row++) {
        if (gameState.board[row].every(cell => cell !== 0)) {
          gameState.board[row] = Array(BOARD_SIZE).fill(0);
          clearedLines++;
	          // showCombo(row, 'linha'); // Removido para chamar uma √∫nica vez no final
        }
      }

      // Verificar colunas
      for (let col = 0; col < BOARD_SIZE; col++) {
        if (gameState.board.every(row => row[col] !== 0)) {
          for (let row = 0; row < BOARD_SIZE; row++) {
            gameState.board[row][col] = 0;
          }
          clearedLines++;
	          // showCombo(col, 'coluna'); // Removido para chamar uma √∫nica vez no final
        }
      }

	      if (clearedLines > 0) {
	        gameState.score += clearedLines * 100;
	      // gameState.level = Math.max(100, gameState.level - clearedLines * 10); // Removido por solicita√ß√£o do usu√°rio
	        showFeedback(clearedLines);
	      }
	    }

	    function showFeedback(clearedCount) {
	      let message = `+${clearedCount * 100} PTS!`;
if (clearedCount > 0) {
        const sounds = [
          { id: 'audioWow', message: 'WOW!' },
          { id: 'audioAmazing', message: 'AMAZING!' },
          { id: 'audioFantastic', message: 'FANTASTIC!' }
        ];
        const randomSound = sounds[Math.floor(Math.random() * sounds.length)];
        message = randomSound.message;
        playSound(randomSound.id);
      }
	
	      const feedback = document.createElement('div');
	      feedback.className = 'combo-animation';
	      feedback.textContent = message;
	      feedback.style.left = '50%';
	      feedback.style.top = '50%';
	      feedback.style.transform = 'translate(-50%, -50%)';
	      document.body.appendChild(feedback);
	
	      setTimeout(() => feedback.remove(), 1000);
	    }

    function canPlaceAnyBlock() {
      if (gameState.blocks.length === 0) return false;

      for (let blockIdx = 0; blockIdx < gameState.blocks.length; blockIdx++) {
        const block = gameState.blocks[blockIdx];
        const shape = block.shape;

        for (let row = 0; row < BOARD_SIZE; row++) {
          for (let col = 0; col < BOARD_SIZE; col++) {
            if (row + shape.length <= BOARD_SIZE && col + shape[0].length <= BOARD_SIZE) {
              let canPlace = true;
              for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                  if (shape[r][c] === 1 && gameState.board[row + r][col + c] !== 0) {
                    canPlace = false;
                    break;
                  }
                }
                if (!canPlace) break;
              }
              if (canPlace) return true;
            }
          }
        }
      }

      return false;
    }

	    function updateDisplay() {
	      document.getElementById('scoreDisplay').textContent = gameState.score;
	      // document.getElementById('levelDisplay').textContent = gameState.level; // Removido por solicita√ß√£o do usu√°rio
	    }

    function endGame() {
      gameState.gameActive = false;
      document.getElementById('finalScore').textContent = gameState.score;
      document.getElementById('gameOverModal').classList.remove('hidden');
      toggleBackgroundMusic(false);
    }

    function openSettings() {
      playSound('audioPop');
      document.getElementById('settingsModal').classList.remove('hidden');
    }

    function closeSettings() {
      playSound('audioPop');
      document.getElementById('settingsModal').classList.add('hidden');
    }

    function toggleSound() {
      playSound('audioPop');
      gameState.soundEnabled = !gameState.soundEnabled;
      const toggle = document.getElementById('soundToggle');
	      if (gameState.soundEnabled) {
	        toggle.classList.add('active');
	        toggleBackgroundMusic(true);
	      } else {
	        toggle.classList.remove('active');
	        toggleBackgroundMusic(false);
	      }
	      // Se o som foi reativado, mas a m√∫sica n√£o estava tocando, inicia a m√∫sica
	      if (gameState.soundEnabled && getAudioElement(currentMusicIndex).paused) {
	        toggleBackgroundMusic(true);
	      }
    }

    function toggleDarkMode() {
      playSound('audioPop');
      gameState.darkMode = !gameState.darkMode;
      const toggle = document.getElementById('darkModeToggle');
      if (gameState.darkMode) {
        document.body.classList.add('dark-mode');
        toggle.classList.add('active');
      } else {
        document.body.classList.remove('dark-mode');
        toggle.classList.remove('active');
      }
    }

    // Inicializar toggles
    function initToggles() {
      const soundToggle = document.getElementById('soundToggle');
      const darkModeToggle = document.getElementById('darkModeToggle');
      
      if (gameState.soundEnabled) {
        soundToggle.classList.add('active');
      }
      if (gameState.darkMode) {
        darkModeToggle.classList.add('active');
      }
    }

	    // Bot√£o voltar para o site
	    const backToSiteBtn = document.getElementById('backToSiteBtn');
	    if (backToSiteBtn) {
	      backToSiteBtn.addEventListener('click', () => {
	        playSound('audioPop'); // Adicionado som de pop
	        window.close();
	        setTimeout(() => {
	          window.location.href = '/index.html';
	        }, 100);
	      });
	    }

    // Inicializar toggles quando o jogo come√ßa
    document.addEventListener('DOMContentLoaded', initToggles);
  </script>
</body>
</html>
